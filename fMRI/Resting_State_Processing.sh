#!/bin/bash

echo "auto-generated by afni_proc.py, Thu Mar  3 12:12:24 2016"
echo "(version 4.09, February 19, 2014)"
echo "execution started: 'date'"

########variables to set

origDir="$(pwd)"
usrDir=$1
mprageDir=$usrDir/mprageNifTi
proj=$2
TRms=$3
tr_cut=$4
TRseconds=$(bc<<<"scale=3;$TRms/1000")

echo "proj = : $proj"
echo "TRms = : $TRms"
echo "TRseconds = : $TRseconds"

epiNIFTIDir=$usrDir/epiNifTi
epiOrigDir=$epiNIFTIDir/orig
epiIntermedProc=$epiNIFTIDir/preprocInter
epiResults=$epiNIFTIDir/results
epiMasks=$epiNIFTIDir/masks
epiRegressors=$epiNIFTIDir/regressors
epiFinalProc=$epiNIFTIDir/preprocFinal
epiReg=$epiNIFTIDir/registration
epiQA=$epiNIFTIDir/qa
subReview=$epiNIFTIDir/review
epiOrigFileName=rawEPI.nii.gz
epiOrigFileNameFullPath=$epiOrigDir/$epiOrigFileName

set rest = rest #name for resting scan
if [ $proj == "H2H2" ]; then
   revPENIFTIDir=$usrDir/revPeNifTi
   revPEOrigDir=$revPENIFTIDir/orig
   revEpiFileName=rawEPI.nii.gz
   #next line should be $revEpiFileName, but not a big deal since they are both identical, it's the path that matters
   revEpiFileNameFullPath=$revPEOrigDir/$epiOrigFileName
    blur=4 #spatial smoothing kernel #ARC NEEDS CHANGE
    doSliceTimingCorrection=0 # ARC NEEDS CHANGE (Addition of this)
    useExtTopUp=0;
    doTopup=1;
    censor=0.3
    matrix=103
    eesp=0.000604
fi
if [ $proj == "ARC" ]; then
    blur=10 #tim changed 08-10-16: this equates to UW smoothness plus 4mm ASN to 10 because THIS equates to UW smoothness+3.5, Siemens + 5-6
    doSliceTimingCorrection=1 # ARC NEEDS CHANGE (Addition of this)
    useExtTopUp=1;
    doTopup=0;
    censor=0.42
    matrix1=80
    eesp1=0.000520
    matrix2=64
    eesp2=0.000372
fi
echo "blur = : $blur"

#anat_dir=${anatDir} #where anatomy and T1 to MNI transforms are stored
polyDegree=3 #Polynomial order for regression

#WM segmentation pve file for BBR registration
wmseg=${mprageDir}/c2MPRAGE.nii.gz
#tissuePriorsWM=/rcc/stor1/projects/BIRP/StandardMaps/avg152T1_white_bin.nii.gz
#tissuePriorsCSF=/rcc/stor1/projects/BIRP/StandardMaps/avg152T1_csf_bin.nii.gz 
tissuePriorsWM=$usrDir/utils/StandardMaps/avg152T1_white_bin.nii.gz
tissuePriorsCSF=$usrDir/utils/StandardMaps/avg152T1_csf_bin.nii.gz 
brainmask=${FSLDIR}/data/standard/MNI152_T1_2mm_brain_mask_dil1.nii.gz
#tim changed brainmask 08-10-16, now WB (with CSF); also, no longer use ventmask
ventmask=${FSLDIR}/data/standard/MNI152_T1_2mm_VentricleMask.nii.gz

#get to directory with subjects, this will definitely change with sub, timepoint etc
#cd ${home_dir}

# =========================== setup ========================================
# script setup
#
# copy skullstripped anatomy to results dir
3dcopy ${mprageDir}/MPRAGE_brain.nii.gz ${epiIntermedProc}/MPRAGE_brain.nii.gz

# ============================ auto block: tcat ============================
# apply 3dTcat to copy input dsets to results dir
sleep 60
3dTcat -tr $TRseconds -prefix ${epiIntermedProc}/rest_tcat.nii.gz ${epiOrigFileNameFullPath}'['${tr_cut}'..$]'

# ========================== auto block: outcount ==========================
# data check: compute outlier fraction for each volume
# Ultimately move to QA????? (keep as is)
touch ${epiQA}/out.pre_ss_warn.txt
3dToutcount -automask -fraction -polort $polyDegree -legendre ${epiIntermedProc}/rest_tcat.nii.gz > ${epiQA}/outcount.1D

# outliers at TR 0 might suggest pre-steady state TRs
if ( '1deval -a ${epiQA}/outcount.1D "{0}" -expr "step(a-0.4)"' ); then
    echo "** TR #0 outliers: possible pre-steady state TRs" >> ${epiQA}/out.pre_ss_warn.txt
fi

# ================================ despike =================================
# apply 3dDespike to each run
3dDespike -NEW -nomask -prefix ${epiIntermedProc}/rest_despike.nii.gz ${epiIntermedProc}/rest_tcat.nii.gz

# =================================distortion correct==================
# Average first few reps

# ARC NEEDS CHANGE--External run with the 2 diffusion sets of up/down
if [ $doTopup -eq 1 ]; then
    duration1="$(echo "$matrix * $eesp" | bc -l)"
    #duration2="$(echo "$matrix2 * $eesp2" | bc -l)"
    echo "0 1 0 ${duration1}" > ${epiIntermedProc}/topupFile.txt
    echo "0 -1 0 ${duration1}" >> ${epiIntermedProc}/topupFile.txt
    
    if [ $useExtTopUp -eq 0 ]; then
        3dTstat -mean -prefix ${epiIntermedProc}/restBlip1Mean.nii.gz \
            ${epiIntermedProc}/rest_tcat.nii.gz
        3dTstat -mean -prefix ${epiIntermedProc}/restBlip2Mean.nii.gz \
            ${revEpiFileNameFullPath}
    else
        3dTstat -mean -prefix ${epiIntermedProc}/restBlip1Mean.nii.gz \
            ${revEpiFileNameFullPathAlpha}
        3dTstat -mean -prefix ${epiIntermedProc}/restBlip2Mean.nii.gz \
            ${revEpiFileNameFullPath}
    fi
        
    3dTcat -tr $TRseconds -prefix ${epiIntermedProc}/upDn.nii.gz \
        ${epiIntermedProc}/restBlip1Mean.nii.gz                  \
        ${epiIntermedProc}/restBlip2Mean.nii.gz
    
    topup --imain=${epiIntermedProc}/upDn.nii.gz                 \
                    --datain=${epiIntermedProc}/topupFile.txt    \
                    --config=b02b0.cnf                           \
                    --out=${epiIntermedProc}/tuResults           \
                    --fout=${epiIntermedProc}/tuField            \
                    --iout=${epiQA}/tuUnwarped
    
    echo "0 1 0 $duration1" > ${epiIntermedProc}/applyTopupFile.txt
    applytopup --imain=${epiIntermedProc}/rest_despike.nii.gz               \
                             --datain=${epiIntermedProc}/applyTopupFile.txt \
                             --method=jac --inindex=1                       \
                             --topup=${epiIntermedProc}/tuResults           \
                             --out=${epiIntermedProc}/restUnwarped
    
    # ================================= align ==================================
    # optional: create base images from initial volume to improve regs
    3dcalc -a ${epiOrigFileNameFullPath}'[0]' 					   \
    	-expr 'a' 							                       \
    	-prefix ${epiReg}/base_rest.nii.gz
    
    applytopup --imain=${epiReg}/base_rest.nii.gz                  \
                             --datain=${epiIntermedProc}/applyTopupFile.txt \
                             --method=jac --inindex=1              \
                             --topup=${epiIntermedProc}/tuResults  \
                             --out=${epiReg}/base_rest_unwarped
    
else
    #${AFNIDIR}/3dcopy ${epiIntermedProc}/rest_despike.nii.gz      \
    #    ${epiIntermedProc}/restUnwarped.nii.gz
    #${AFNIDIR}/3dcopy ${epiReg}/base_rest.nii.gz                  \
    #    ${epiReg}/base_rest_unwarped.nii.gz
    3dcalc -a ${epiOrigFileNameFullPath}'[0]' 					   \
    	-expr 'a' 							                       \
    	-prefix ${epiReg}/base_rest.nii.gz
    3dcalc -prefix ${epiIntermedProc}/restUnwarped.nii.gz -a ${epiIntermedProc}/rest_despike.nii.gz -expr "a"
    3dcalc -prefix ${epiReg}/base_rest_unwarped.nii.gz -a ${epiReg}/base_rest.nii.gz -expr "a"
fi


#BBR registration, needs WM segmentation 
# DROPPED FROM NEXT STEP
#${FSLPATH}/fslmaths ${wmseg} -thr 0.10 -bin ${epiReg}/BBR_wmseg 

epi_reg --epi=${epiReg}/base_rest_unwarped.nii.gz          \
	--t1=${mprageDir}/MPRAGE.nii.gz	 					   \
	--t1brain=${mprageDir}/MPRAGE_brain.nii.gz			   \
	--out=${epiReg}/rest2MPRAGE
	#--wmseg=${epiReg}/BBR_wmseg.nii.gz 				   \

##get mask of voxels that have func data 
3dcalc -a ${epiReg}/rest2MPRAGE.nii.gz 					   \
	-expr 'notzero(a)' 						               \
	-prefix ${epiIntermedProc}/notzero.nii.gz
3dmask_tool -fill_holes 						           \
	-input ${epiIntermedProc}/notzero.nii.gz    		   \
	-prefix ${epiMasks}/rest2MPRAGE_mask.nii.gz
rm ${epiIntermedProc}/notzero.nii.gz

##get binary brain mask in native space
3dcalc -a ${mprageDir}/MPRAGE_brain.nii.gz 				   \
	-expr 'ispositive(a)' 						           \
	-prefix ${epiMasks}/MPRAGE_mask.nii.gz
###dilate this mask a bit
3dmask_tool -dilate_input 2 						       \
	-prefix ${epiMasks}/MPRAGE_mask_dil.nii.gz 		   	   \
	-input ${epiMasks}/MPRAGE_mask.nii.gz

## intersection of native brain mask and nonzero func mask
3dcalc -a ${epiMasks}/MPRAGE_mask_dil.nii.gz 			   \
	-b ${epiMasks}/rest2MPRAGE_mask.nii.gz 				   \
	-expr 'a*b' -prefix ${epiMasks}/MPRAGE_rest_mask.nii.gz

# ================================ slice timing correction ================
#Block added for ARC
if [ $doSliceTimingCorrection -eq 1 ]; then
   3dTshift -TR $TRseconds -tpattern altplus -tzero -quintic -prefix ${epiIntermedProc}/volregInput.nii.gz  ${epiIntermedProc}/restUnwarped.nii.gz
else
   3dcopy ${epiIntermedProc}/restUnwarped.nii.gz ${epiIntermedProc}/volregInput.nii.gz
fi

# ================================= volreg =================================
# register each volume to the base 
# volregIput has replaced restUnwarped with addition of above block for ARC
3dvolreg -verbose -zpad 1 						           \
	-base ${epiReg}/base_rest_unwarped.nii.gz'[0]'		   \
	-1Dfile ${epiQA}/motion_raw.1D 						   \
	-prefix ${epiIntermedProc}/rest_volreg.nii.gz		   \
	-cubic								                   \
	-1Dmatrix_save ${epiIntermedProc}/volreg.1D			   \
	${epiIntermedProc}/volregInput.nii.gz

# compute motion magnitude time series: the Euclidean norm
# (sqrt(sum squares)) of the motion parameter derivatives
1d_tool.py -infile ${epiQA}/motion_raw.1D -set_nruns 1     \
           -derivative  -collapse_cols euclidean_norm      \
           -write ${epiQA}/motion_enorm.1D

# --------------------------------------
# create a TSNR dataset

3dTstat -mean -prefix ${epiQA}/signal.nii.gz                \
    ${epiIntermedProc}/rest_volreg.nii.gz

3dDetrend -polort $polyDegree							    \
	-prefix ${epiQA}/rm.noise.det.nii.gz					\
	-overwrite ${epiIntermedProc}/rest_volreg.nii.gz
3dTstat -stdev -prefix ${epiQA}/noise.nii.gz ${epiQA}/rm.noise.det.nii.gz
#ASN removed mask from below tSNR calculation 5/30/16
3dcalc -a ${epiQA}/signal.nii.gz                            \
       -b ${epiQA}/noise.nii.gz                             \
       -expr 'a/b' -prefix ${epiQA}/rest_TSNR.nii.gz 

rm ${epiQA}/rm.noise.det.nii.gz

###
# ========================== Move Func to template space ===================
#  concatenate previously obtained EPI to T1 and the T1 to templaate
convert_xfm -omat ${epiReg}/rest2standard.mat 			    \
	-concat ${mprageDir}/MPRAGE2standard.mat ${epiReg}/rest2MPRAGE.mat

#apply the previously calculated NL warp to get EPI to standard space
applywarp --ref=${FSLDIR}/data/standard/MNI152_T1_2mm.nii.gz \
	--in=${epiIntermedProc}/rest_volreg.nii.gz 			     \
	--out=${epiReg}/rest2standard_NL 						 \
	--warp=${mprageDir}/MPRAGE2standard_warp.nii.gz		     \
	--premat=${epiReg}/rest2MPRAGE.mat

# ====== Get FOV mask in standard space and intersect with brain mask======
3dcalc -a ${epiReg}/rest2standard_NL.nii.gz 				 \
	-expr 'notzero(a)' 						                 \
	-prefix ${epiMasks}/notzero_NL.nii.gz
3dmask_tool -fill_holes -input ${epiMasks}/notzero_NL.nii.gz \
	-prefix ${epiMasks}/FOV_mask_NL.nii.gz
rm ${epiMasks}/notzero_NL.nii.gz

#tim changed 08-10-16: reflects fact that brainmask is now whole brain
3dcalc -a ${epiMasks}/FOV_mask_NL.nii.gz -b ${brainmask}     \
	-expr 'a*b' -prefix ${epiMasks}/rest_wholeBrain_mask.nii.gz

# ================================ regress =================================
# compute de-meaned motion parameters (for use in regression)
1d_tool.py -infile ${epiQA}/motion_raw.1D -set_nruns 1       \
           -demean -write ${epiRegressors}/motion_demean.1D

# compute motion parameter derivatives (for use in regression)
1d_tool.py -infile ${epiQA}/motion_raw.1D -set_nruns 1       \
           -derivative -demean -write ${epiRegressors}/motion_deriv.1D

#calculate censor file
	#ADDED  08-12-16
1d_tool.py -infile ${epiQA}/motion_raw.1D -set_nruns 1       \
	-show_censor_count -censor_prev_TR -censor_motion ${censor} ${epiRegressors}/motion

#get average white matter and CSF signals from masks
if [ -e ${tissuePriorsCSF} ]; then
    3dmaskave -quiet -mask ${tissuePriorsCSF} ${epiReg}/rest2standard_NL.nii.gz | 1d_tool.py -infile - -demean -write ${epiRegressors}/CSF.1D
else
    echo "ERROR: ${tissuePriorsCSF} doesn't exist"
    #exit
    kill -INT $$
fi
if [ -e ${tissuePriorsWM} ]; then
    3dmaskave -quiet -mask ${tissuePriorsWM} ${epiReg}/rest2standard_NL.nii.gz | 1d_tool.py -infile - -demean -write ${epiRegressors}/WM.1D
else
    echo "ERROR: ${tissuePriorsWM} doesn't exist"
    #exit
    kill -INT $$
fi

# run the regression analysis
##Tim updated 08-12-16, added x1D stop; using 3dTProject for regression now
3dDeconvolve -input ${epiReg}/rest2standard_NL.nii.gz   \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz       \
    -ortvec ${epiRegressors}/WM.1D WM                   \
    -ortvec ${epiRegressors}/CSF.1D CSF					\
    -polort $polyDegree                                 \
    -num_stimts 12                                      \
    -stim_file 1 ${epiRegressors}/motion_demean.1D'[0]' \
        -stim_base 1 -stim_label 1 roll_01   \
    -stim_file 2 ${epiRegressors}/motion_demean.1D'[1]' \
        -stim_base 2 -stim_label 2 pitch_01  \
    -stim_file 3 ${epiRegressors}/motion_demean.1D'[2]' \
        -stim_base 3 -stim_label 3 yaw_01    \
    -stim_file 4 ${epiRegressors}/motion_demean.1D'[3]' \
        -stim_base 4 -stim_label 4 dS_01     \
    -stim_file 5 ${epiRegressors}/motion_demean.1D'[4]' \
        -stim_base 5 -stim_label 5 dL_01     \
    -stim_file 6 ${epiRegressors}/motion_demean.1D'[5]' \
        -stim_base 6 -stim_label 6 dP_01     \
    -stim_file 7 ${epiRegressors}/motion_deriv.1D'[0]'  \
        -stim_base 7 -stim_label 7 roll_02    \
    -stim_file 8 ${epiRegressors}/motion_deriv.1D'[1]'  \
        -stim_base 8 -stim_label 8 pitch_02   \
    -stim_file 9 ${epiRegressors}/motion_deriv.1D'[2]'  \
        -stim_base 9 -stim_label 9 yaw_02     \
    -stim_file 10 ${epiRegressors}/motion_deriv.1D'[3]' \
        -stim_base 10 -stim_label 10 dS_02   \
    -stim_file 11 ${epiRegressors}/motion_deriv.1D'[4]' \
        -stim_base 11 -stim_label 11 dL_02   \
    -stim_file 12 ${epiRegressors}/motion_deriv.1D'[5]' \
        -stim_base 12 -stim_label 12 dP_02   \
	-fout -tout -x1D ${epiRegressors}/X.xmat.1D         \
        -xjpeg ${epiRegressors}/X.jpg                   \
    -fitts ${epiRegressors}/fitts.nii.gz                \
    -errts ${epiFinalProc}/noiseRegressed.nii.gz        \
	-x1D_stop                                           \
    -bucket ${epiRegressors}/stats.nii.gz

# if 3dDeconvolve fails, terminate the script
if [ $? -ne 0 ]; then
    echo '---------------------------------------'
    echo '** 3dDeconvolve error, failing...'
    echo '   (consider the file 3dDeconvolve.err)'
    #exit
    kill -INT $$
fi

# perform the nuisance regression using 3dTproject
	###TIM added 08-12-16
3dTproject -polort 0 \
	-input ${epiReg}/rest2standard_NL.nii.gz \
	-ort ${epiRegressors}/X.xmat.1D \
	-prefix ${epiFinalProc}/noiseRegressed.nii.gz

3dTproject -polort 0 \
	-input ${epiReg}/rest2standard_NL.nii.gz \
	-censor ${epiRegressors}/motion_censor.1D \
	-cenmode NTRP \
	-ort ${epiRegressors}/X.xmat.1D \
	-prefix ${epiFinalProc}/noiseRegressedCensor.nii.gz

#### ADD SMOOTHING & SMOOTHNES ESTIMATION HERE
if [ $proj == "ARC" ]; then
    3dBlurToFWHM -FWHM ${blur} \
            -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz	   \
    	    -prefix ${epiFinalProc}/noiseRegressed_${blur}mm.nii.gz   \
            -input ${epiFinalProc}/noiseRegressed.nii.gz

    3dBlurToFWHM -FWHM ${blur} \
            -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz	   \
    	    -prefix ${epiFinalProc}/noiseRegressedCensor_${blur}mm.nii.gz   \
            -input ${epiFinalProc}/noiseRegressedCensor.nii.gz
fi

if [ $proj == "H2H2" ]; then
    3dBlurInMask -FWHM ${blur} \
            -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz	   \
    	    -prefix ${epiFinalProc}/noiseRegressed_${blur}mm.nii.gz   \
            -input ${epiFinalProc}/noiseRegressed.nii.gz
    
    3dBlurInMask -FWHM ${blur} \
            -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz	   \
    	    -prefix ${epiFinalProc}/noiseRegressedCensor_${blur}mm.nii.gz   \
            -input ${epiFinalProc}/noiseRegressedCensor.nii.gz
fi

#Run in processed space after smoothing
3dFWHMx -detrend \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz -acf NULL           \
    ${epiFinalProc}/noiseRegressed.nii.gz >> ${epiFinalProc}/fwhmx.1D

3dFWHMx -detrend \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz -acf NULL             \
    ${epiFinalProc}/noiseRegressed_${blur}mm.nii.gz >> \
    ${epiFinalProc}/fwhmx.blur.1D

3dFWHMx -detrend \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz -acf NULL           \
    ${epiFinalProc}/noiseRegressedCensor.nii.gz >> ${epiFinalProc}/fwhmxCensor.1D

3dFWHMx -detrend \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz -acf NULL             \
    ${epiFinalProc}/noiseRegressedCensor_${blur}mm.nii.gz >> \
    ${epiFinalProc}/fwhmxCensor.blur.1D

### split the fwhm.acf files into acf and fwhm files
sed 'n; d' ${epiFinalProc}/fwhmx.1D > ${epiFinalProc}/smooth.fwhm.1D
sed '1d; n; d' ${epiFinalProc}/fwhmx.1D > ${epiFinalProc}/smooth.acf.1D 

sed 'n; d' ${epiFinalProc}/fwhmx.blur.1D > ${epiFinalProc}/smooth.blur.fwhm.1D
sed '1d; n; d' ${epiFinalProc}/fwhmx.blur.1D > ${epiFinalProc}/smooth.blur.acf.1D

sed 'n; d' ${epiFinalProc}/fwhmxCensor.1D > ${epiFinalProc}/smoothCensor.fwhm.1D
sed '1d; n; d' ${epiFinalProc}/fwhmxCensor.1D > ${epiFinalProc}/smoothCensor.acf.1D 

sed 'n; d' ${epiFinalProc}/fwhmxCensor.blur.1D > ${epiFinalProc}/smoothCensor.blur.fwhm.1D
sed '1d; n; d' ${epiFinalProc}/fwhmxCensor.blur.1D > ${epiFinalProc}/smoothCensor.blur.acf.1D

#####NEW SCRIPT STARTS HERE ####### OR BUNDLE INTO ONE?
# display any large pariwise correlations from the X-matrix

###########################################
###ASN for doing all 4 data sets at once###
###########################################

#Bandpass with 3dRSFC & calculate paramters
3dRSFC -prefix ${epiResults}/RSFC -nodetrend				   \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz	           \
	-band 0.01 0.1 							   \
	-input ${epiFinalProc}/noiseRegressed.nii.gz

3dRSFC -prefix ${epiResults}/RSFC_${blur}mm -nodetrend				   \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz	           \
	-band 0.01 0.1 							   \
	-input ${epiFinalProc}/noiseRegressed_${blur}mm.nii.gz

3dRSFC -prefix ${epiResults}/RSFCCensor -nodetrend				   \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz	           \
	-band 0.01 0.1 							   \
	-input ${epiFinalProc}/noiseRegressedCensor.nii.gz

3dRSFC -prefix ${epiResults}/RSFCCensor_${blur}mm -nodetrend				   \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz	           \
	-band 0.01 0.1 							   \
	-input ${epiFinalProc}/noiseRegressedCensor_${blur}mm.nii.gz

#Run the REHO
3dReHo -prefix ${epiResults}/RSFC_REHO \
    -inset ${epiResults}/RSFC_LFF+tlrc 			   \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz				   

3dReHo -prefix ${epiResults}/RSFC_${blur}mm_REHO \
    -inset ${epiResults}/RSFC_${blur}mm_LFF+tlrc 			   \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz				   

3dReHo -prefix ${epiResults}/RSFCCensor_REHO \
    -inset ${epiResults}/RSFCCensor_LFF+tlrc 			   \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz				   

3dReHo -prefix ${epiResults}/RSFCCensor_${blur}mm_REHO \
    -inset ${epiResults}/RSFCCensor_${blur}mm_LFF+tlrc 			   \
    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz				   

#Convert output to NII
for RSFC in ALFF LFF RSFA fALFF fRSFA mALFF mRSFA REHO; do
    3dcopy ${epiResults}/RSFC_${RSFC}+tlrc \
        ${epiResults}/RSFC_${RSFC}.nii.gz
    rm ${epiResults}/RSFC_${RSFC}+tlrc*
    
    3dcopy ${epiResults}/RSFC_${blur}mm_${RSFC}+tlrc \
        ${epiResults}/RSFC_${blur}mm_${RSFC}.nii.gz
    rm ${epiResults}/RSFC_${blur}mm_${RSFC}+tlrc*

    3dcopy ${epiResults}/RSFCCensor_${RSFC}+tlrc \
        ${epiResults}/RSFCCensor_${RSFC}.nii.gz
    rm ${epiResults}/RSFCCensor_${RSFC}+tlrc*
    
    3dcopy ${epiResults}/RSFCCensor_${blur}mm_${RSFC}+tlrc \
        ${epiResults}/RSFCCensor_${blur}mm_${RSFC}.nii.gz
    rm ${epiResults}/RSFCCensor_${blur}mm_${RSFC}+tlrc*
done

for RSFC in ALFF RSFA fALFF fRSFA REHO; do
    touch ${epiResults}/rm.${RSFC}.stats.txt
    touch ${epiResults}/rm.${blur}mm${RSFC}.stats.txt
    touch ${epiResults}/rm.Censor${RSFC}.stats.txt
    touch ${epiResults}/rm.Censor${blur}mm${RSFC}.stats.txt

    3dmaskave -quiet -sigma \
	    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz \
    	${epiResults}/RSFC_${RSFC}.nii.gz \
	    > ${epiResults}/rm.${RSFC}.stats.txt
    m="cat ${epiResults}/rm.${RSFC}.stats.txt |awk '{print $1}'"
    s="cat ${epiResults}/rm.${RSFC}.stats.txt |awk '{print $2}'"

    3dmaskave -quiet -sigma \
	    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz \
    	${epiResults}/RSFC_${blur}mm_${RSFC}.nii.gz \
	    > ${epiResults}/rm.${blur}mm${RSFC}.stats.txt
    mBlur="cat ${epiResults}/rm.${blur}mm${RSFC}.stats.txt |awk '{print $1}'"
    sBlur="cat ${epiResults}/rm.${blur}mm${RSFC}.stats.txt |awk '{print $2}'"

    3dmaskave -quiet -sigma \
	    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz \
    	${epiResults}/RSFCCensor_${RSFC}.nii.gz \
	    > ${epiResults}/rm.Censor${RSFC}.stats.txt
    mCensor="cat ${epiResults}/rm.Censor${RSFC}.stats.txt |awk '{print $1}'"
    sCensor="cat ${epiResults}/rm.Censor${RSFC}.stats.txt |awk '{print $2}'"

    3dmaskave -quiet -sigma \
	    -mask ${epiMasks}/rest_wholeBrain_mask.nii.gz \
    	${epiResults}/RSFCCensor_${blur}mm_${RSFC}.nii.gz \
	    > ${epiResults}/rm.Censor${blur}mm${RSFC}.stats.txt
    mCensorBlur="cat ${epiResults}/rm.Censor${blur}mm${RSFC}.stats.txt |awk '{print $1}'"
    sCensorBlur="cat ${epiResults}/rm.Censor${blur}mm${RSFC}.stats.txt |awk '{print $2}'"

    3dcalc -a ${epiResults}/RSFC_${RSFC}.nii.gz \
	    -b ${epiMasks}/rest_wholeBrain_mask.nii.gz \
	    -expr "b*((a-${m})/${s})" \
	    -prefix ${epiResults}/RSFC_${RSFC}_Z.nii.gz

    3dcalc -a ${epiResults}/RSFC_${blur}mm_${RSFC}.nii.gz \
	    -b ${epiMasks}/rest_wholeBrain_mask.nii.gz \
	    -expr "b*((a-${mBlur})/${sBlur})" \
	    -prefix ${epiResults}/RSFC_${blur}mm_${RSFC}_Z.nii.gz

    3dcalc -a ${epiResults}/RSFCCensor_${RSFC}.nii.gz \
	    -b ${epiMasks}/rest_wholeBrain_mask.nii.gz \
	    -expr "b*((a-${mCensor})/${sCensor})" \
	    -prefix ${epiResults}/RSFCCensor_${RSFC}_Z.nii.gz

    3dcalc -a ${epiResults}/RSFCCensor_${blur}mm_${RSFC}.nii.gz \
	    -b ${epiMasks}/rest_wholeBrain_mask.nii.gz \
	    -expr "b*((a-${mCensorBlur})/${sCensorBlur})" \
	    -prefix ${epiResults}/RSFCCensor_${blur}mm_${RSFC}_Z.nii.gz

    #ln -s ${epiResults}/RSFC_${blur}mm_${RSFC}_Z.nii.gz ${subReview}/standard/
    #ln -s ${epiResults}/RSFCCensor_${blur}mm_${RSFC}_Z.nii.gz ${subReview}/standard/
done #RSFC

#Compute & store GCOR
#Step 1
3dTnorm -norm2 -prefix ${epiQA}/rm.errts.unit.nii.gz \
    ${epiResults}/RSFC_LFF.nii.gz

3dTnorm -norm2 -prefix ${epiQA}/rm.${blur}mmerrts.unit.nii.gz \
    ${epiResults}/RSFC_${blur}mm_LFF.nii.gz

3dTnorm -norm2 -prefix ${epiQA}/rm.Censorerrts.unit.nii.gz \
    ${epiResults}/RSFCCensor_LFF.nii.gz

3dTnorm -norm2 -prefix ${epiQA}/rm.Censor${blur}mmerrts.unit.nii.gz \
    ${epiResults}/RSFCCensor_${blur}mm_LFF.nii.gz
#Step 2
3dmaskave -quiet \
	-mask ${epiMasks}/rest_wholeBrain_mask.nii.gz \
    ${epiQA}/rm.errts.unit.nii.gz > ${epiQA}/gmean.errts.unit.1D

3dmaskave -quiet \
	-mask ${epiMasks}/rest_wholeBrain_mask.nii.gz \
    ${epiQA}/rm.${blur}mmerrts.unit.nii.gz > ${epiQA}/gmean${blur}mm.errts.unit.1D

3dmaskave -quiet \
	-mask ${epiMasks}/rest_wholeBrain_mask.nii.gz \
    ${epiQA}/rm.Censorerrts.unit.nii.gz > ${epiQA}/gmeanCensor.errts.unit.1D

3dmaskave -quiet \
	-mask ${epiMasks}/rest_wholeBrain_mask.nii.gz \
    ${epiQA}/rm.Censor${blur}mmerrts.unit.nii.gz > ${epiQA}/gmeanCensor${blur}mm.errts.unit.1D
#Step 3
3dTstat -sos -prefix - ${epiQA}/gmean.errts.unit.1D\' \
    > ${epiQA}/out.gcor.1D

3dTstat -sos -prefix - ${epiQA}/gmean${blur}mm.errts.unit.1D\' \
    > ${epiQA}/out${blur}mm.gcor.1D

3dTstat -sos -prefix - ${epiQA}/gmeanCensor.errts.unit.1D\' \
    > ${epiQA}/outCensor.gcor.1D

3dTstat -sos -prefix - ${epiQA}/gmeanCensor${blur}mm.errts.unit.1D\' \
    > ${epiQA}/outCensor${blur}mm.gcor.1D
#Step 4
rm ${epiQA}/rm.*errts.unit*

## Put results where they should be
mv ${epiResults}/RSFC_LFF* ${epiFinalProc}
mv ${epiResults}/RSFC_${blur}mm_LFF* ${epiFinalProc}
mv ${epiResults}/RSFCCensor_LFF* ${epiFinalProc}
mv ${epiResults}/RSFCCensor_${blur}mm_LFF* ${epiFinalProc}

echo "execution finished: 'date'"




# ==========================================================================
# script generated by the command:
#
# afni_proc.py -subj_id subj123 -dsets subj123/run.nii.gz -copy_anat       \
#     anatT1.nii.gz -blocks despike align volreg blur mask regress         \
#     -tcat_remove_first_trs 16 -volreg_align_e2a -volreg_compute_tsnr yes \
#     -blur_size 4.0 -mask_apply epi -mask_segment_anat yes                \
#     -mask_segment_erode yes -regress_bandpass 0.01 0.1                   \
#     -regress_apply_mot_types demean deriv -regress_ROI WMe -regress_ROI  \
#     CSFe -regress_RSFC -regress_run_clustsim no -regress_est_blur_errts  \
#     -regress_compute_tsnr no
#
#     ...and heavily modified thereafter
